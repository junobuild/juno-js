import {isNullish} from '@dfinity/utils';
import {PUBLIC_KEY_COSE_ALGORITHMS} from './_constants';
import {WebAuthnHostnameError} from './errors';
import {CreatePasskeyOptions, PasskeyOptions} from './types';

const randomValue = (): BufferSource => window.crypto.getRandomValues(new Uint8Array(16));

/**
 * When creating a passkey, the challenge can simply be a random value.
 * Since the server doesn’t need to verify the authenticity of the key,
 * it doesn’t have to generate the challenge itself.
 *
 * In contrast, when signing a request with our credentials,
 * the request itself becomes the data (blob), the challenge, that must be signed.
 */
const createChallenge = (): BufferSource => randomValue();

/**
 * The user ID is set to a random value, which holds little relevance
 * for the end user beyond being unique.
 *
 * Ultimately, once signed in, the user's actual identifier will be
 * the public key (principal) of the identity used to interact with the IC.
 */
const createUserId = (): BufferSource => randomValue();

const hostname = (): string => {
  const {
    location: {href}
  } = window;

  const url = URL.parse(href);

  if (isNullish(url)) {
    throw new WebAuthnHostnameError();
  }

  const {hostname} = url;

  return hostname;
};

const relyingPartyId = ({appId}: Pick<PasskeyOptions, 'appId'>): string => appId?.id ?? hostname();

export const createPasskeyOptions = ({
  appId,
  user: userOptions
}: CreatePasskeyOptions): PublicKeyCredentialCreationOptions => {
  const {
    document: {title: name}
  } = window;

  const relyingParty = (): Pick<PublicKeyCredentialCreationOptions, 'rp'> => ({
    rp: {
      // Note: deprecated in WebAuthn L3
      name: appId?.name ?? name,
      id: relyingPartyId({appId})
    }
  });

  const user = (): Pick<PublicKeyCredentialCreationOptions, 'user'> => ({
    user: {
      id: createUserId(),
      name: userOptions?.name ?? userOptions?.displayName ?? name,
      displayName: userOptions?.displayName ?? name
    }
  });

  return {
    // We want to receive the attestation statement as generated by the authenticator
    attestation: 'direct',
    challenge: createChallenge(),
    ...relyingParty(),
    ...user(),
    pubKeyCredParams: Object.values(PUBLIC_KEY_COSE_ALGORITHMS).map((algorithm) => ({
      type: 'public-key',
      alg: algorithm
    })),
    excludeCredentials: [],
    authenticatorSelection: {
      // At least for now, we want a simplified flow and therefore indicates that we want a
      // platform authenticator ((an authenticator embedded to the platform device).
      authenticatorAttachment: 'platform',
      userVerification: 'preferred',
      // Along with requireResidentKey, make passkey discoverable,
      residentKey: 'required',
      requireResidentKey: true
    }
  };
};

export const retrievePasskeyOptions = (
  options: PasskeyOptions
): Omit<PublicKeyCredentialRequestOptions, 'challenge'> => ({
  rpId: relyingPartyId(options),
  allowCredentials: [],
  userVerification: 'required'
});
